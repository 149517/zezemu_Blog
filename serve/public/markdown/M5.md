## 其他

###  1. 柯里化

柯里化是一种函数式编程技术，它将接受多个参数的函数转化为一系列只接受一个参数的函数。通过柯里化，您可以将函数的参数逐一传递，每次传递一个参数，返回一个新的函数，直到所有参数都传递完毕，最后返回结果。这有助于提高函数的可组合性和复用性。

```js
function add(a) {
  return function(b) {
    return a + b;
  };
}

const addFive = add(5);
console.log(addFive(3)); // 输出 8

```



###  2. 前端性能指标，以及性能优化（Perfomance对象上的都是）

####  性能优化

前端性能指标包括页面加载时间、首次绘制时间、用户交互响应时间等。性能优化是一种通过优化代码、资源加载、网络请求等方式来改善前端应用程序的性能的实践。一些性能优化策略包括：

- **代码分割**：将代码分割成小块，按需加载，减少初始加载时间。
- **缓存**：合理使用浏览器缓存，减少资源重复下载。
- **异步加载**：使用异步加载资源，不阻塞页面渲染。
- **图片优化**：使用适当大小和格式的图像，懒加载或预加载图片。
- **减少网络请求**：合并请求、减少不必要的请求。
- **压缩和混淆代码**：减小文件大小，提高加载速度。
- **前端框架和库的选择**：选择性能较高的前端框架和库。
- **服务端渲染**：使用服务器端渲染（SSR）来加速首次渲染。



####  Performance对象

`Performance`对象是浏览器提供的API之一，用于收集和测量Web应用程序的性能数据。通过`Performance`对象，您可以访问诸如页面加载时间、资源加载时间、用户交互延迟等性能指标。这些数据可以用于性能分析和优化。

您可以使用`window.performance`来访问`Performance`对象，并使用其方法和属性来检索性能信息。例如，`performance.timing`属性提供了有关页面加载时间的详细信息。



### 3. BFF开发和前端开发的思维有什么不一样

BFF（Backend For Frontend）开发和前端开发虽然都涉及构建Web应用程序，但它们的重点和思维方式略有不同：

1. **关注点**：
   - 前端开发更关注用户界面和用户体验，包括UI设计、用户交互和前端技术栈。
   - BFF开发更关注服务端的业务逻辑和数据交互，主要负责与后端API通信、数据预处理和组合，以提供给前端最佳的数据和性能。
2. **技术栈**：
   - 前端开发通常使用HTML、CSS、JavaScript以及相关的前端框架和库，用于构建用户界面。
   - BFF开发可能涉及更广泛的后端技术，包括服务器端语言、数据库、API设计等，以及与前端通信的RESTful API或GraphQL。
3. **性能优化**：
   - 前端开发通常关注浏览器性能、页面加载速度、用户交互等前端性能指标。
   - BFF开发更侧重于后端性能、数据处理、API性能等，以确保前端能够高效地获取所需的数据。
4. **安全性**：
   - 前端开发需要考虑浏览器安全性，防止XSS（跨站脚本攻击）等前端安全问题。
   - BFF开发需要考虑后端安全性，包括数据验证、身份验证、授权等，以保护后端API和敏感数据。

总的来说，BFF开发和前端开发都是构建Web应用程序的关键部分，但它们关注不同的方面，前端侧重于用户界面和用户体验，而BFF侧重于后端业务逻辑和数据处理。在实际项目中，BFF和前端通常需要紧密协作，以实现最佳的端到端应用程序性能和用户体验。



###  4. 当时的BFF是前端负责运维的吗，如果上线后BFF报错，怎么排查bug

BFF（Backend For Frontend）通常是由后端团队负责运维和维护的，因为它涉及到与后端服务和数据交互的后端逻辑。前端团队负责开发前端应用程序，而不是维护后端的BFF层。

如果上线后的BFF报错，前端团队通常不会直接负责排查和解决这些问题。相反，前端团队可能会与后端团队紧密合作，共同协助排查问题。以下是一些可能的排查步骤：

1. **查看日志**：后端通常会记录BFF的请求和错误信息。查看BFF的日志文件以确定报错的原因和位置。
2. **检查代码**：后端开发人员会检查BFF的代码，查找潜在的bug或异常处理问题。这可能涉及查看错误处理代码、请求参数处理等。
3. **测试环境复现**：尝试在开发或测试环境中复现问题，以便更容易地调试和分析问题。
4. **排查网络问题**：确保与后端服务的通信正常。检查网络请求是否正确、响应是否有异常、数据格式是否一致等。
5. **性能分析**：如果性能是问题的原因，使用性能分析工具来检查响应时间、资源消耗等。
6. **升级依赖项**：如果问题与依赖项相关，尝试升级或降级依赖项版本，以查看问题是否得到解决。

总的来说，BFF报错的排查通常需要后端开发人员和前端开发人员之间的协作，以便快速诊断问题并采取适当的措施来解决它。

###  5. SVN和Git的区别

SVN（Subversion）和Git都是版本控制系统，用于跟踪和管理软件项目的代码变更，但它们有一些重要的区别：

1. **分布式 vs. 集中式**：
   - Git是分布式版本控制系统，每个开发者都有完整的代码仓库的副本，可以在本地工作和提交更改，然后将更改推送到中央仓库。
   - SVN是集中式版本控制系统，所有的代码仓库都托管在中央服务器上，开发者需要从中央服务器检出代码，并将更改提交到中央服务器。
2. **分支和合并**：
   - Git的分支和合并非常轻量和灵活，允许开发者创建和合并分支以支持并行开发和功能开发。
   - SVN的分支和合并通常较为复杂，需要谨慎操作，且不如Git灵活。
3. **性能**：
   - Git通常在性能上表现得更好，因为大部分操作都在本地执行，而不需要频繁与中央服务器通信。
   - SVN在某些情况下可能在大型仓库和复杂分支结构下性能下降。
4. **历史跟踪**：
   - Git对文件的历史跟踪更强大，能够准确地跟踪文件的每个修改，包括重命名和移动操作。
   - SVN也可以跟踪历史，但不如Git灵活。
5. **分支和标签**：
   - Git的分支和标签是轻量的，可以随意创建和删除。
   - SVN的分支和标签通常需要在仓库中创建复制，并占用额外的存储空间。

总的来说，Git在分布式开发、分支管理、性能和历史跟踪等方面通常更具优势，而SVN适用于集中式开发和较简单的项目。选择使用哪个版本控制系统通常取决于项目需求和团队的偏好。



###  6. 低代码平台用了防抖的策略，那如果用户修改了几次，使用防抖会不会被吞并了一些修改的操作，这又是怎么去处理的？

防抖是一种控制函数调用频率的策略，它确保在一段时间内，只有最后一次函数调用会被执行，而之前的调用会被忽略。这在某些场景下是有用的，例如处理用户输入的搜索建议或滚动事件。然而，在某些情况下，如果用户连续修改了多次，防抖可能会导致一些修改操作被吞并。

要处理这种情况，可以考虑以下几种方法：

1. **增加防抖延迟时间**：增加防抖的延迟时间，以允许用户在连续修改时有更多的时间。这样可以减少修改被吞并的可能性，但可能会增加响应时间。
2. **使用节流**：节流是另一种控制函数调用频率的策略，它确保在一段时间内，函数以固定的频率被调用。与防抖不同，节流不会忽略任何调用，而是按照固定的频率执行。这可以确保用户的修改操作都会被处理，但可能会降低性能。
3. **增加缓冲区**：在连续修改的情况下，可以将修改操作存储在缓冲区中，然后在一段时间内将所有操作一次性处理。这样可以确保所有修改都被记录和处理，但需要适当管理缓冲区以防止内存泄漏或性能问题。
4. **实时保存和撤销**：另一种方法是实时保存用户的修改操作，同时允许用户撤销或恢复操作。这样，用户可以在需要时自己控制何时保存或丢弃修改。

具体选择哪种方法取决于应用程序的需求和用户体验的权衡。通常，根据具体场景来决定是否使用防抖、节流或其他控制策略。



###  7. 共享文档缓存的策略涉及到什么算法？该算法使用到了什么数据结构？

共享文档缓存是一种用于提高文档访问性能的策略，通常用于协作文档编辑应用程序或分布式文件系统中。它涉及到许多算法和数据结构，其中一些包括：

1. **缓存算法**：常见的缓存算法包括LRU（最近最少使用）、LFU（最不经常使用）、FIFO（先进先出）等。这些算法用于确定哪些文档应该保留在缓存中，以便快速访问，哪些应该被替换。
2. **数据结构**：常见的数据结构包括哈希表、红黑树、链表等，用于实现缓存和快速查找文档。哈希表用于存储文档的元数据，以便快速查找文档。链表和树结构用于管理缓存中文档的顺序和替换策略。
3. **版本控制算法**：在协作文档编辑应用程序中，需要考虑版本控制算法，以管理多个用户同时编辑同一文档的情况。一些常见的版本控制算法包括OT（操作转换）和CRDT（可复制数据类型）等。
4. **分布式存储和同步策略**：在分布式文件系统中，需要考虑数据分布、复制、同步策略等。这可能涉及到分布式哈希表、数据分片、一致性协议等。
5. **安全策略**：保护文档数据的安全性也是一个重要考虑因素。常见的安全策略包括数据加密、访问控制、身份验证等。





###  8. 说一下electron的理解

Electron 是一个开源的桌面应用程序开发框架，允许开发者使用常见的Web技术，如HTML、CSS和JavaScript，来构建跨平台的桌面应用程序。它使用了Chromium作为渲染引擎和Node.js作为后端引擎，将Web技术与本地桌面应用程序的能力相结合。以下是对 Electron 的关键理解：

1. **跨平台性**：Electron 允许开发者使用相同的代码库构建适用于多个操作系统（如Windows、macOS和Linux）的桌面应用程序，从而降低了跨平台开发的难度。
2. **使用Web技术**：开发者可以使用熟悉的Web前端技术，如HTML、CSS和JavaScript，来构建用户界面和应用程序的前端部分。
3. **Node.js 后端**：Electron 提供了 Node.js 环境，允许开发者编写后端逻辑，并访问操作系统的本地功能，如文件系统、网络、操作系统API等。
4. **自定义窗口和界面**：Electron 提供了灵活的窗口管理和自定义界面的能力，开发者可以创建各种窗口和界面元素来满足应用程序的需求。
5. **打包和分发**：Electron 提供了工具和方法，用于将应用程序打包为可执行文件，并分发到不同的操作系统平台。
6. **生态系统丰富**：由于 Electron 的流行，拥有丰富的插件和扩展库，可帮助开发者实现各种功能，如自动更新、数据库访问、桌面通知等。



###  9. 构建和编译有没有了解呢？



构建和编译是软件开发过程中的关键步骤，用于将源代码转化为可执行的应用程序或库。在 Electron 应用程序的开发中，构建和编译也是必要的步骤。以下是构建和编译在 Electron 开发中的一些关键概念：

1. **构建前端代码**：前端部分通常由 HTML、CSS 和 JavaScript 组成。开发者可以使用文本编辑器或集成开发环境（IDE）来编写前端代码。
2. **安装依赖**：通常，Electron 应用程序依赖第三方 JavaScript 库和 Node.js 模块。使用包管理工具如 npm 或 yarn 来安装这些依赖项。
3. **构建主进程**：Electron 应用程序有两个主要进程，一个是渲染进程（前端），另一个是主进程（后端）。开发者需要构建和配置主进程的逻辑，这通常是在 Node.js 中完成的。
4. **打包资源**：将前端资源（HTML、CSS、JavaScript 文件）和 Electron 主进程脚本一起打包到应用程序的文件夹中，以便构建。
5. **配置打包工具**：选择并配置适合自己应用程序的构建和打包工具。一些常见的工具包括 Electron Builder、Electron Forge 等。
6. **编译应用程序**：将应用程序的源代码和资源打包到可执行文件中。这个过程会生成用于不同操作系统（如 Windows、macOS、Linux）的应用程序文件。
7. **测试和调试**：在构建和编译后，开发者需要进行测试和调试以确保应用程序的正常运行。这包括功能测试、性能测试和错误调试。
8. **发布应用程序**：发布编译后的应用程序，以便用户下载和安装。这可以在不同的应用商店、网站或分发渠道进行。

构建和编译是将 Electron 应用程序从源代码转化为可分发的桌面应用程序的关键步骤，它涉及到许多工具和配置，以确保应用程序在不同平台上的稳定性和性能。